//этот класс обращается к файлу <ApplicationContext> считывает его и помещает все бины которые там описаны в ClassPathXmlApplicationContext
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
        );

Scope Singleton
Используется по умолчанию. По умолчанию создаётся один объект (до вызова метода getBean()).
При всех вызовах getBean() возвращается ссылка на один и тот же объект.
Scope Singleton чаще всего используется тогда, когда у нашего бина нет неизменяемых состояний. Потому что если мы будем изменять состояние у Singleton бина, столкнёмся с проблемой.

* MusicPlayer firstMusicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
  MusicPlayer secondMusicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
  в этом случае будет создавать всегда один и тот же объект

Scope Prototype
Scope, который каждый раз создаёт новый объект при вызове getBean().
Scope Prototype чаще всего используется тогда, когда у нашего бина есть неизменяемые состояния.

* MusicPlayer firstMusicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
  MusicPlayer secondMusicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
  в этом случае будут создаваться каждый раз новый объект при вызове метода getBean().

Жизненный цикл Бина:
Запускается Spring приложение -> Запускается Spring контейнер -> Создаётся объект бина -> В бин внедряются зависимости(Dependency Injection) ->
-> Вызывается init-method у бина -> Бин готов к использованию -> Бин будет передан пользователю -> Завершается Spring приложение ->
-> Вызывается указанный destroy-method -> Остановка Spring приложения

init-method
Метод который запускается в ходе инициализации бина(Чаще всего это инициализация ресурсов, обращение к внешним файлам, запуск БД.

destroy-method
Метод, который запускается в ходе уничтожения бина(при завершении приложения), в частности это очищение ресурсов, закрытие потоков ввода-вывода, закрытие доступа к БД.

factory-method(Фабричный метод) - этот паттерн предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода.
Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод(иногда это полезно)

Тонкости методов init-method и destroy-method:
У обоих методов могут быть любые модификаторы доступа.
Так же у них может быть любой тип возвращаемого значения, но чаще всего это void(т.к. нет возможности получить возвращаемое значение).
Они не должны ничего принимать в аргументы и их название может быть любым.
Для бинов со scope prototype Spring не вызывает destroy метод. Spring отдаёт prototype бины клиенту и больше о них не заботиться(в отличии от singleton бинов)

Независимо от того, что мы используем фабричный метод, у нас будет использоваться Scope Singleton, и объект будет создаваться один раз, независимо от того, сколько раз мы его вызовем.

По умолчанию у бинов Scope Singleton.

Java Аннотации - это специальный тип комментариев в вашем коде с помощью которых можно:

Зачем использовать аннотации:
- Короче чем XML конфигурация
- Удобнее чем XML конфигурация
- Код становится более читабельным

Как работает конфигурация с помощью аннотаций:
- Spring сканирует все классы
- Находит классы со специальными аннотациями и автоматически создаёт бины из этих классов

Аннотация @Component:
- Помечаем ей класс, если хотим, чтобы Spring Framework создал бин из этого класса
- Именно эту аннотацию Spring Framework ищет, когда сканирует все ваши классы
- Можно указать id для создаваемого бина, можно не указывать(тогда название будет <название класса с маленькой буквы>)

Как работает аннотация @Autowired:
- Spring сканирует все классы на аннотации @Component и создаёт бины для этих классов
- Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один в качестве зависимости там, где мы указали аннотацию @Autowired
- Если находится один подходящий бин, он внедряется в качестве зависимости
- Если не находится не одного - ошибка
- Если несколько бинов подходят - неоднозначность и тоже будет выброшена ошибка
- Аннотация @Autowired подбирает подходящие бины по их типу(класс или интерфейс)
- Аннотация @Autowired можно использовать на полях, сеттерах и конструкторах

Аннотация @Qualifier(англ. Уточнитель) - указываем id того бина, который мы хотим внедрить:
Эту аннотацию можно использовать на:
- Конструкторах
- Сеттерах
- Полях

Внедрение зависимости на поля:
  @Autowired
  @Qualifier("rockMusic") // сделали так, что бы бин в поле внедрялся только бин rockMusic
  private Music music;

Внедрение зависимости на конструктор(Аннотацию необходимо использовать рядом с аргументами конструктора):
    @Autowired
    public MusicPlayer( @Qualifier("rockMusic") Music music1,
                        @Qualifier("classicalMusic") Music music2) {
              this.music1 = music1;
              this.music2 = music2;
    }


В классах можно использовать блоки инициализации они обозначаются двумя скобками и между ними код,
который будет выполнятся всегда, когда создаётся объект класса.
*
public class ClassicalMusic {
    private final List<String> songs = new ArrayList<>();

    {
        songs.add("Middle of a night");
        songs.add("This is America");
        songs.add("Weekend lots");
    }


Аннотация @Value - какое значение будет внедрятся в наше поле(@Value("${musicPlayer.name}"))

Аннотация @Scope("singleton or prototype") - эту аннотацию мы передаём над названием класса

Аннотация @PostConstruct - вызывается указанный init-method
Аннотация @PreDestroy - вызывается указанный destroy-method
Их методы не должны ничего принимать в аргументы методов
* @PostConstruct
  public void doMyInit() {
        System.out.println("Doing my initialization");
  }

  @PreDestroy
  public void doMyDestroy() {
        System.out.println("Doing my destruction");
  }


Аннотация @Configuration - помечаем Java класс, который мы хотим использовать для конфигурации Spring приложения.
Пустой конфигурационный Java класс равен по функционалу пустому конфигурационному.
*
@Configuration
public class SpringConfig {
}

Для каждого XML тега есть соответствующая аннотация:
<context:component-scan base-package="ru.poplaukhin.spring" для этого тега есть Java аннотация:

@Configuration
@ComponentScan("ru.poplaukhin.spring")
public class SpringConfig {
}


